http://blog.chinaunix.net/uid-693168-id-3453399.html
C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。
       对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。下面给出一些例子来进行说明。
 int a = 10;
 int b = 20;
 int *pFlag = &a;
 vector<int> vctTemp;
 vctTemp.push_back(1);
 string str1 = "hello ";
 string str2 = "world";
 const int &m = 1;
       请问，a，b, a+b, a++, ++a, pFlag, *pFlag, vctTemp[0], 100, string("hello"), str1, str1+str2, m分别是左值还是右值？
           a和b都是持久对象（可以对其取地址），是左值；
           a+b是临时对象（不可以对其取地址），是右值；
           a++是先取出持久对象a的一份拷贝，再使持久对象a的值加1，最后返回那份拷贝，而那份拷贝是临时对象（不可以对其取地址），故其是右值；
           ++a则是使持久对象a的值加1，并返回那个持久对象a本身（可以对其取地址），故其是左值；
           pFlag和*pFlag都是持久对象（可以对其取地址），是左值；
           vctTemp[0]调用了重载的[]操作符，而[]操作符返回的是一个int &，为持久对象（可以对其取地址），是左值；
           100和string("hello")是临时对象（不可以对其取地址），是右值；
           str1是持久对象（可以对其取地址），是左值；
           str1+str2是调用了+操作符，而+操作符返回的是一个string（不可以对其取地址），故其为右值；
           m是一个常量引用，引用到一个右值，但引用本身是一个持久对象（可以对其取地址），为左值。
      区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用和常量左值引用。
      非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。
      常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。
      可以看出，使用左值引用时，我们无法区分出绑定的是否是非常量右值的情况。那么，为什么要对非常量右值进行区分呢，区分出来了又有什么好处呢？这就牵涉到C++中一个著名的性能问题——拷贝临时对象。考虑下面的代码：
vector<int> GetAllScores()
{
 vector<int> vctTemp;
 vctTemp.push_back(90);
 vctTemp.push_back(95);
 return vctTemp;
}
复制代码
       当使用vector<int> vctScore = GetAllScores()进行初始化时，实际上调用了三次构造函数。尽管有些编译器可以采用RVO（Return Value Optimization）来进行优化，但优化工作只在某些特定条件下才能进行。可以看到，上面很普通的一个函数调用，由于存在临时对象的拷贝，导致了额外的两次拷贝构造函数和析构函数的开销。当然，我们也可以修改函数的形式为void GetAllScores(vector<int> &vctScore)，但这并不一定就是我们需要的形式。另外，考虑下面字符串的连接操作：
 string s1("hello");
 string s = s1 + "a" + "b" + "c" + "d" + "e";
复制代码
       在对s进行初始化时，会产生大量的临时对象，并涉及到大量字符串的拷贝操作，这显然会影响程序的效率和性能。怎么解决这个问题呢？如果我们能确定某个值是一个非常量右值（或者是一个以后不会再使用的左值），则我们在进行临时对象的拷贝时，可以不用拷贝实际的数据，而只是“窃取”指向实际数据的指针（类似于STL中的auto_ptr，会转移所有权）。C++ 11中引入的右值引用正好可用于标识一个非常量右值。C++ 11中用&表示左值引用，用&&表示右值引用，如：
 int &&a = 10; 
       右值引用根据其修饰符的不同，也可以分为非常量右值引用和常量右值引用。
       非常量右值引用只能绑定到非常量右值，不能绑定到非常量左值、常量左值和常量右值（VS2010 beta版中可以绑定到非常量左值和常量左值，但正式版中为了安全起见，已不允许）。如果允许绑定到非常量左值，则可能会错误地窃取一个持久对象的数据，而这是非常危险的；如果允许绑定到常量左值和常量右值，则非常量右值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义。
       常量右值引用可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值（理由同上）。
       有了右值引用的概念，我们就可以用它来实现下面的CMyString类。
class CMyString
{
public:
    // 构造函数
 CMyString(const char *pszSrc = NULL)
 {
  cout << "CMyString(const char *pszSrc = NULL)" << endl;
  if (pszSrc == NULL)
  {
   m_pData = new char[1];
   *m_pData = '\0';
  }
  else
  {
   m_pData = new char[strlen(pszSrc)+1];
   strcpy(m_pData, pszSrc);
  }
 }

    // 拷贝构造函数
 CMyString(const CMyString &s)
 {
  cout << "CMyString(const CMyString &s)" << endl;
  m_pData = new char[strlen(s.m_pData)+1];
  strcpy(m_pData, s.m_pData);
 }

    // move构造函数
 CMyString(CMyString &&s)
 {
  cout << "CMyString(CMyString &&s)" << endl;
  m_pData = s.m_pData;
  s.m_pData = NULL;
 }

    // 析构函数
 ~CMyString()
 {
  cout << "~CMyString()" << endl;
  delete [] m_pData;
  m_pData = NULL;
 }

    // 拷贝赋值函数
 CMyString &operator =(const CMyString &s)
 {
  cout << "CMyString &operator =(const CMyString &s)" << endl;
  if (this != &s)
  {
   delete [] m_pData;
   m_pData = new char[strlen(s.m_pData)+1];
   strcpy(m_pData, s.m_pData);
  }
  return *this;
 }

    // move赋值函数
 CMyString &operator =(CMyString &&s)
 {
  cout << "CMyString &operator =(CMyString &&s)" << endl;
  if (this != &s)
  {
   delete [] m_pData;
   m_pData = s.m_pData;
   s.m_pData = NULL;
  }
  return *this;
 }

private:
 char *m_pData;
};
复制代码
        可以看到，上面我们添加了move版本的构造函数和赋值函数。那么，添加了move版本后，对类的自动生成规则有什么影响呢？唯一的影响就是，如果提供了move版本的构造函数，则不会生成默认的构造函数。另外，编译器永远不会自动生成move版本的构造函数和赋值函数，它们需要你手动显式地添加。
        当添加了move版本的构造函数和赋值函数的重载形式后，某一个函数调用应当使用哪一个重载版本呢？下面是按照判决的优先级列出的3条规则：
             1、常量值只能绑定到常量引用上，不能绑定到非常量引用上。
             2、左值优先绑定到左值引用上，右值优先绑定到右值引用上。
             3、非常量值优先绑定到非常量引用上。
        当给构造函数或赋值函数传入一个非常量右值时，依据上面给出的判决规则，可以得出会调用move版本的构造函数或赋值函数。而在move版本的构造函数或赋值函数内部，都是直接“移动”了其内部数据的指针（因为它是非常量右值，是一个临时对象，移动了其内部数据的指针不会导致任何问题，它马上就要被销毁了，我们只是重复利用了其内存），这样就省去了拷贝数据的大量开销。
        一个需要注意的地方是，拷贝构造函数可以通过直接调用*this = s来实现，但move构造函数却不能。这是因为在move构造函数中，s虽然是一个非常量右值引用，但其本身却是一个左值（是持久对象，可以对其取地址），因此调用*this = s时，会使用拷贝赋值函数而不是move赋值函数，而这已与move构造函数的语义不相符。要使语义正确，我们需要将左值绑定到非常量右值引用上，C++ 11提供了move函数来实现这种转换，因此我们可以修改为*this = move(s)，这样move构造函数就会调用move赋值函数。
C++的Lambda表达式在WIN RT的异步编程中，占有非常重要的作用。但C++的Lambda表达式又不同于其他语言，比如C#，javascript。本篇旨在讨论C++ Lambda表达式的基本语法和概念，希望大家多多指正。
 
 首先，我们看一下Lambda表达式的基本构成
 
1. 是捕获值列表，2.是传入参数列表，3.可修改标示符，4.错误抛出标示符，5.函数返回值，6.是函数体。
 
在.NET 中，我们认为比较标准的Lambda表达式应该是这个样子
// declaring_lambda_expressions1.cpp
#include <functional>

int main()
{
   // Assign the lambda expression that adds two numbers to an auto variable.
   auto f1 = [] (int x, int y) { return x + y; }; 

   // Assign the same lambda expression to a function object.
   function<int (int, int)> f2 = [] (int x, int y) { return x + y; };
   f1(3,4); 
复制代码
}
f1是一个auto的值，也是function<>这个模板类型，我们可以理解成为一个函数指针。然后我们用f1(3,4)去调用他。
 
如果我们想在函数声明的时候就直接执行他，我们可以在Lambda表达式的最后加传入参数，像这样。
int main()
{
   using namespace std;
   int n = [] (int x, int y) { return x + y; }(5, 4);

   //assign the return type
   int n = [] (int x, int y) -> int{ return x + y;}(5, 4);
   cout << n << endl;
复制代码
}
第二个表达式中声明的返回值必须跟随->符号，并且两个必须同时出现。如果返回值唯一的话，我们可以省略->+返回值类型。
Lambda表达式允许返回值不唯一的情况，但必须指定返回值类型。
在以上的例子当中，只是常规的Lambda表达式用法，下面我们要说一说捕获值列表。
 
捕获值列表，是允许我们在Lambda表达式的函数体中直接使用这些值，捕获值列表能捕获的值是所有在此作用域可以访问的值，包括这个作用域里面的临时变量，类的可访问成员，全局变量。捕获值的方式分两种，一种是按值捕获，一种是按引用捕获。顾名思义，按值捕获是不改变原有变量的值，按引用捕获是可以在Lambda表达式中改变原有变量的值。
[&] 所有的值都是按引用捕获
[=] 所有的值都是按值捕获
如果你不想某些值被按引用或者按值捕获，但其他的值却想那样做的话
[ &, n ] 除了n 所有的值按引用捕获
[ = , &n ]除了n所有的值按值捕获
当然，我们也可以指定某几个值的捕获属性
[ m, n ]m,n按引用捕获
[ &m, &n ]m,n按值捕获
 
       int m = 0, n = 0;
    
      [=] (int a) mutable { m = ++n + a; }(4);
      [&] (int a) { m = ++n + a; }(4);

      [=,&m] (int a) mutable { m = ++n + a; }(4);
      [&,m] (int a) mutable { m = ++n + a; }(4);

      [m,n] (int a) mutable { m = ++n + a; }(4);
      [&m,&n] (int a) { m = ++n + a; }(4);

      [=] (int a) mutable { m = ++n + a; }(4);
复制代码
 
大家一定好奇为什么这里有很多mutable。在按值引用的情况下，Lambda函数体内部是不能直接修改引用值的。如下面注释代码，是会报错的。这种情况下，我们要在Lambda表达式前加mutable，但是结果m,n 依然没有被修改，维持按值引用的特性。
int main()
{
      int m = 0, n = 0;
      // 不加mutable会报错
      //[=] (int a){ m = ++n + a; }(4);
      //[m,n] (int a){ m = ++n + a; }(4);

      [=] (int a) mutable { m = ++n + a; }(4);
     //
     // [=] (int m, int n, int a){m=++n+a; }(m, n, 4);
     // 下面这个函数m,n的值依然会被修改，因为m,n是按引用传入的
     // [=] (int &m, int &n, int a){m=++n+a; }(m, n, 4);
      cout << m << endl << n << endl;
复制代码
}
 
 在这个例子中捕获值列表[this]中的this是用来指向这个类的，但[this]只有在类的内部，或者是this指针存在的情况下才能使用。
class Scale
{
public:
   // The constructor.
   explicit Scale(int scale)
      : _scale(scale)
   {
   }

   // Prints the product of each element in a vector object 
   // and the scale value to the console.
   void ApplyScale(const vector<int>& v) const
   {
      for_each(v.begin(), v.end(), 
         [this](int n) { cout << n * _scale << endl; });
   }

private:
   int _scale;
};
 
关于异常：
我们可以通过try-catch去捕获异常，而在Lambda表达式中声明throw()，是指示编译器这个函数不会抛异常，会引起编译的警告。
 
然后，Lambda可以支持返回函数指针，或者说是嵌套一个Lambda表达式，比如：
int main()
{
   using namespace std;

   // The following lambda expression contains a nested lambda
   // expression.
   int m = [](int x) 
      { return [](int y) { return y * 2; }(x) + 3; }(5);

   // Print the result.
   cout << m << endl;
复制代码
}
我们可以把 return [](int y) { return y * 2; }(x) 抽象成 f(x) 所以原函数就是return f(5)+3 就是2*5+3=13
 
加入函数指针之后，我们来看一看一个Lambda表达式可以写的多复杂，这是来自于MSDN的官方的例子。
// higher_order_lambda_expression.cpp
// compile with: /EHsc
#include <iostream>
#include <functional>

int main()
{
   using namespace std;

   // The following code declares a lambda expression that returns 
   // another lambda expression that adds two numbers. 
   // The returned lambda expression captures parameter x by value.
   auto g = [](int x) -> function<int (int)> 
      { return [=](int y) { return x + y; }; };

   // The following code declares a lambda expression that takes another
   // lambda expression as its argument.
   // The lambda expression applies the argument z to the function f
   // and adds 1.
   auto h = [](const function<int (int)>& f, int z) 
      { return f(z) + 1; };

   // Call the lambda expression that is bound to h. 
   auto a = h(g(7), 8);

   // Print the result.
   cout << a << endl;
复制代码
}
 
 
 
结果很简单就是7+8+1=16 我通过代码帮大家展开一下：
   auto g = [](int x) -> function<int (int)> 
      { return [=](int y) { return x + y; }; };

   auto h = [](const function<int (int)>& f, int z) 
      { return f(z) + 1; };

   auto a = h(g(7), 8);
   // 解：
   // 我们先看看g(7) 等于什么
   // 我们把g的返回值 return [=](int y) { return x + y; }; 抽象成一个函数t(y)
   // 那么g(x)返回的就t(y)
   // 也就是g(7)=t(y) 这里g的参数和t的参数无关
   // 那么 h(g(7), 8)=h(t(y), 8))
   // 代入h的表达式，我们发现t(y)就是f(z)
   // 代入的结果就是 return t(8)+1,再把g(7)代入就是7+8+1=16
   
复制代码
   cout << a << endl; 
 
最后，有人会很好奇foe_each为什么可以传入Lambda表达式
首先，我们看看for_each的展开
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function f)
  {
    for ( ; first!=last; ++first ) f(*first);
    return f;
  }
复制代码
//From: http://www.cplusplus.com/reference/algorithm/for_each/ 
 当然这不是实际的代码，但是我们可以看到，调用的只是f()再传入迭代器的值，所以，我们在写for_each的Lambda表达式的时候，传入参数一定是和迭代器的类型是匹配的。
在没有Lambda表达式的时候，只要是能写成 f(*first)这样的东西传进来的都行，所以就会出现结构体重载()操作符，这样的奇葩
void myfunction (int i) {
  cout << " " << i;
}

struct myclass {
  void operator() (int i) {cout << " " << i;}
} myobject;

int main () {
  vector<int> myvector;
  myvector.push_back(10);
  myvector.push_back(20);
  myvector.push_back(30);

  cout << "myvector contains:";
  for_each (myvector.begin(), myvector.end(), myfunction);

  // or:
  cout << "\nmyvector contains:";
  for_each (myvector.begin(), myvector.end(), myobject);

  cout << endl;

  return 0;
复制代码
}
 
在C++中Lambda表达式被设计的相对复杂，但我相信，这也是C++这门语言的魅力所在，功能很强大，但是很难学。
