RegExp
在编写处理字符串程序时，经常会有查找符合某些负责规则的字符串的需要。正则表达式就是用于描述这些规则的
工具。换句话说，正则表达式就是记录文本规则的代码。
在Qt C++中有QRegExp，在QML中有RegExp，它们是对字符串执行模式匹配的强大工具。
在ECMAScript中支持两种构造正则表达式的方法：
字面量语法： /pattern/attributes。
创建RegExp对象： new RegExp(pattern, attributes)。
使用字面量这种方式，我们在前面介绍的String类的match()和search()方法时已经用到过。创建RegExp对象与
字面量方式类似，它们都需要设置pattern和attributes。

原字符串是："I\'m a string",我们使用"/String/"作为参数来调用search(),没有找到结果，当我们使用
"/String/i"就能找到了。

在"/String/i"这个正则表达式中，"/String"就是模式(pattern)，它是最简单的模式，使用的是字符串字面量。
这是我们在使用记事本，Qt Creator，word等软件时最常用的查找文本的方式;使用字符串进行精确查找。虽然字符串字面量是一种合法的
正则表达式，但它显然没有发挥出正则表达式的强大威力，仅仅牛刀杀鸡而已。

正则表达式本事是一个非常复杂的主题，笔者不准备详细展开，这里只简单介绍修饰符，元字符，
重复(量词)， 字符转义，字符集合等常见的正则表达式组成元素，以及如何使用他们完成简单的字符串匹配，
更进一步的学习请参考相关的专门的书籍和文章。

在"/String/i"， i是修饰符，表示忽略大小写，这个正则表达式的意思是匹配String这个单词，
不管大小写。对应的RegExp对象可以这么构建：RegExp("String", "i");或者这么构建：new RegExp("Stirng", "i")
如下面查找语句
var str = new String("I\'m a string");
        str.match(/String/i);
        str.search(new RegExp("String", "i"));
        str.search(RegExp("String", "i"));
        
        
1.修饰符
在QML中可以使用的修饰符有三个：
"i", 匹配时忽略大小写
"g", 查找所有匹配而非在找到第一个匹配后停止，即全局匹配
"m", 执行多行匹配。

var numbeSource = new String("2014-08-18, I got 96");
var results = numbeSource.match(/\d+/g);
在这个示例中，我们用g来进行全局匹配，否则match()找到第一个数字后就终止模式匹配过程。
"/\d+/g"这个正则表达式，除了使用修饰符，还使用到了元字符和量词。咱们先看看元字符。

(2) 元字符
元字符是拥有特殊含义的字符。
先解释一下"\d+"这个模式。\d是元字符，表示查找数字。+ 是量词，表示重复一次或者多次
那"\d+"的意思就是匹配一个或多个连续的数字，所以在前面的示例中，使用console.log打印
results，输出结果是： [2014,08,18,96]        
如你所见，它匹配到了原字符串中的4个数字。
常用的元字符如下：
"."，匹配除换行符以外的任意字符。
"\w", 匹配字母，数字，下画线或汉字。
"\s", 匹配任意的空白符。
"\S", 匹配非空白符。
"\d", 匹配数字。
"\D", 匹配非数字字符。
"\b", 匹配单词的开始或结束。
"^", 匹配字符串的开始。
"$", 匹配字符串的结束。

比如你处理一个字符串，要提取以"We"开头的所有行，可以使用"/^We.*/mg"。示例代码：
var str1 = "We are dogs;\nYour dogs;\nWe want meat, please.\nPlease.";
var lines = str1.match(/^We.*/mg);
console.log(lines.length);
console.log(lines);

上面的代码将匹配出"We are dogs;"和"We want meat,please." 这两行。模式"^We"表示匹配以"We"
开始的字符串; "*" 表示匹配换行符以外的任意字符， "*"是量词，表示重复0次或者多次;修饰符"mg"
表示开启多行匹配模式并且进行全局匹配。
"m"修饰符会改变元字符"^"和"$"匹配的边界。当时用"m"时,"^"可以匹配每一行的开始，而"$"匹配到换行符之前的
字符。

3. 重复
前面我们已经使用过+ 和 * 这两个量词来匹配重复，下面是经常在正则表达式中使用的量词，你可以用它们来匹配重复。
"*" , 重复0次或者更多次
"+", 重复一次或更多次
"?", 重复0次或一次
"{n}", 重复n次
"{n,}", 重复n次或更多次
"{n,m}", 重复n到m次
假如你要使用QML来匹配一段文本中出现西安市029-nnnnnnnn, 029nnnnnnnn这两种格式的固定号码，
例如： "/029-?\d{8}/mg"

4. 字符集合
要想查找数字，字母，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义
元字符的字符集合 (比如：x, y, z),应该怎么办？
很简单，你只需要在方括号里列出它们就行了，像[xyz]就匹配x，y，z中的一个，[()（）]匹配'(', ')', '（', '）'中的一个

我们也可以轻松地指定一个字符范围，像[0-9]代表的含义与\d一样; [a-zA-Z]表示26个英文字符
举个例子：还是匹配西安市的电话号码，添加对" (029) nnnnnnnn", "（029）nnnnnnnnn" 这两种形式的支持，可以使用下面de
正则表达式：
[(（]?029[))-]?\d{8}/mg

5. 转义字符
最后要说的是转义字符，有时可能想匹配"*"或者".", 怎么办呢？它们被作为元字符使用的啊？
很简单，只要使用"\*", "\."即可。如果你要查找"\"本身，可以使用"\\"。
我们常见的"\0", "\n", "\r", "\t"也都是可以使用的。

最后，需要说明的是，String类的serach(), match(),replace(), split()四个方法支持正则表达式。






























