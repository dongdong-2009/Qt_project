k个用户是从文本的行数中获取的， 其中照片中的数据集d的i次方，只是个表示符号，不是计算的数据


其中xmk，(m下，k上)表示的是第k个用户对第m个对象的感知数据，是文本文件中的读取就可以，不需要生成的
然后生成一个大素数，大素数p是多少位的二进制数呢？512位使用gmp生成
还有一个整数g  gmp生成一个随机数即可

/////////////////////////////已经废弃/////////////////////////////////
用循环群来生成这个东西？
element_random(g);//随机生成g
  element_random(secret_key);//随机生成secret_key
  element_pow_zn(public_key, g, secret_key);//public_key = g^secret_key
  //当要对一个消息进行签名时，首先需要对其进行hash，使用一些标准的哈希算法，哈希过程没有涉及到pairing 所以 很遗憾pbc库中没有提供
  element_from_hash(h, "ABCDEF", 6);//假设hash消息后得ABCDEF（48bit的哈希），这个函数的作用时map these bytes to an element h of G1
  element_pow_zn(sig, h, secret_key);//sig = h^secret_key
////////////////////////////已经废弃//////////////////////////////////

所有用户公用一个大素数p和整数g
p是生成一个512位的大素数，g是p的生成元，即与p互质，取2<= g < p即可，使用取模p的算法就可以了，判断是否大于等于2

私钥都是随机生成的，公钥由公式计算得来的，公钥为g的私钥次方的值取p的模，保存起来
引入随机数h，给以上的k个用户生成唯一的序列号 Seq(i) 属于 [1,k]，目前以文件的对应行数作为其id，也就是第1行id为1，第n行，id为n
给文件的每一行定一个序列号：就为行号，1,2,3,4...k;

为每一个用户生成私钥 ai (ai < p 这个大素数)
可以使用数组来存储这些私钥，方法已经有了
公钥和私钥和g都保存在各自用户的空间中了

文本内容是要加密的数据，私钥和公钥都是生成加密秘钥的部分
刚开始和文本内容毫无关系。后面等生成了加密秘钥后，
再把文本内容和加密秘钥按位异或在一起，生成密文


假如文本第一行也就是第一个用户的数据是100，101，102，103。
那第一个用户的加密秘钥就是ski，为第一个用户和k-1个skij异或而成。
她的密文就是100（这里100，101，102，103要转换成二进制方便异或操作
）按位异或ski，101按位异或ski，102按位异或ski，103按位异或ski，
/XXXXXXXXXXXXXXX
关于skij的计算是用户i分别用自己的私钥和另外的k-1个用户的公钥分别
进行计算得到skij，对用户i的每一个skij求hash值，再对hash值异或得到用户i的ski的值
XXXXXXXXXXXXXXX/error

yi是公钥，ai为私钥
关于skij的值是 yj的ai次方 skji 为yi的aj次方 分别取余p
skij其实就是别人公钥的我的私钥次方，取余p 用户1有k-1个skij分别为sk12，sk13，sk14，....sk1k-1
ski就是对所得到的skij取hash后，再异或得到的数值


skij = yj^ai mod p = (g^aj mod p)^ai mod p
skji = yi^aj mod p = (g^ai mod p)^aj mod p
现在采用的是1,2的方案，也就是不在aiaj的时候mod p，而是单独先mod p的
那么 (g^aj mod p)^ai 与  (g^ai mod p)^aj 就不一定能保证相等了吧？这样也不能满足幂次方的交换律了吧？

g = 2  p = 17 pub = 2^pri% p  pri为(随机数)

user1 pri = 3 sk12 = (g^a2% p)^a1 %p = (2^4 % 17)^3 % 17 = 16^3 % 17 = 4096 % 17 = 16
user2 pri = 4 sk21 = (g^a1% p)^a2 %p = (2^3 % 17)^4 % 17 = 8^4 % 17 = 4096 % 17 = 16

hash数值在以16进制表示时始终是40bit位，但是以10进制或者2进制打印时，例如2进制的，可能是158位甚至是157位，高位的0是不显示的
所以无需奇怪，确实是如此的情况。


这一步和文本的内容无关，只为了得到加密密钥
后面对文本文件的m个观测数据再和加密密钥异或得到m个加密的密文数据

对于每一个的观测数据的加密数据都需要k-1个的虚假数据，然后组合


得到密文数据后，还需要虚假数据的密文，
用k-1个零比特串分别和ski异或加密得到k-1个虚假数据的密文
再将真假数据的密文按之前的唯一序列号:真数据的密文放在序列号的那个框中，
其他虚假数据放在另外k-1个框中。这里可以用数组表示。
然后将所有的组合值进行异或，得到一组数值，对其每个L位求出来，就是明文数值



在一个时间周期内只有一组公钥和私钥。
我们做实验只要做一个时间周期的就可以了，所以只要一组。
不过私钥是由随机函数生成的，可以把随机种子设为时间间隔。
私钥可以通过随机数生成一个
只要是小于p的都可以，不要求是素数，位数也不做要求。
只要最后生成的skij和h(skij)是和文本内容位数相同的01比特串就可以了

真值的求法：
就是k个用户对同一个数据的观测求其真值


代码实现过程
1. 实现 按行读取文件的每一行数据存起来存到了QList的一个list表中，设置id和文本内容
2. 使用pbc的库使用乘法循环群来得到大素数p和g