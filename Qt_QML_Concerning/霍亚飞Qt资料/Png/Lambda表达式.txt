上一节讲述了Qt5全新的信号和槽语法，可以看到Qt5提高了信号和槽关联的灵活性，允许使用任意函数作为槽函数。但是如果想更好地执行异步代码，连函数都不想定义，能否在从哦你呢传统关联时指定信号发出时执行的代码呢？通过Lambda表达式可以达到这儿个目的。
在signalslot.pro项目文件中，添加"CONFIG += c++11",然后保存。
修改connect语句
connect(dlg, &StringDialog::stringChanged, [=](QString str) {
	if (str == "qt") {
		ui->stringLabel->setText("hello qt!");
	}
	else {
		ui->stringLabel->setText("error!");
	}
});

这里直接在connect语句中添加了信号发射后要执行的代码，使用参数值区别显示不同的字符串。这种写法就是所谓的Lambda表达式。Lambda表达式是c++11 新增加的特性。简单来说，Lambda表达式就是匿名函数。在C++11中，它以一对方括号开始。这对括号被称为Lambda表达式引入符。引入符后面可以添加Lambda表达式的返回值类型，之后是参数列表，最后是Lambda表达式的函数体。

不同的Lambda表达式引入符有不同的含义。引入符描述函数体如何”获得“外部变量。这一过程被称为”捕获“。所谓”外部变量“，指的是函数体以外的变量。这些变量需要在引入符可见的作用域有定义。


[]      不捕获任何外部变量
[=]     以传值的方式捕获所有外部变量
[&]     以传引用的方式捕获所有外部变量
[x, &y] x以传值的方式捕获，y以传引用的方式捕获
[=, &x] x以传引用的方式捕获，其余外部变量则以传值的方式捕获
[&, x]  x以传值的方式捕获，其余外部变量则以引用的方式捕获

例如：一个Lambda表达式需要两个参数，以传值方式捕获的a和以引用方式捕获的str，其返回值是QString类型，那么这个Lambda表达式应该写成：
[a, &str]->QString{}

对于带有默认函数的槽函数，可以使用Lambda表达式作为一个匿名函数，达到函数封装的目的。依旧以上文提到的函数为例，可以使用下面的代码重写：
connect(myWidget, &MyWidget::aSignal, []() { pushButton->animateClick()});


像下面的这2段代码该如何理解，信号的发送者，和发送什么信号都是已知的，信号的接受者，和接收后如何处理从哪可以看出来 
connect(pWork,&Work::ImageDone, [=](QImage image){
        m_image=image;
        update();
    });

    connect(this,&MyWidget::destroyed,[=](){
        pthread->quit();
        pthread->wait();
        delete pWork;
    });
    
理解是很好理解的 就是一个匿名函数           [&](){//这里面敲代码}    ，外层再套一个connect(); 。&可以函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。
