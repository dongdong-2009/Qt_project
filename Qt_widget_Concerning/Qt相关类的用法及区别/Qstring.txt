Qt下 QString转char*
Qt下面，字符串都用QString，确实给开发者提供了方便，想想VC里面定义的各种变量类型，而且函数参数类型五花八门，经常需要今年新那个类型转换

Qt再使用第三方开源库时，由于库的类型基本上都是标准的类型，字符串遇的多的就是Char*类型

在Qt下怎样将QString转char*呢，需要用到QByteArray类，QByteArray类的说明详见Qt帮助文档。

因为char*最后都有一个‘/0’作为结束符，而采用QString::toLatin1()时会在字符串后面加上‘/0’

方法如下：

Qstring  str;

char*  ch;

QByteArray ba = str.toLatin1();    

ch=ba.data();

这样就完成了QString向char*的转化。经测试程序运行时不会出现bug

注意第三行，一定要加上，不可以str.toLatin1().data()这样一部完成，可能会出错。



void ProducerFromBottom::ReadyreadSlots()
{
    QByteArray arr = my_serialport->readAll();
    qDebug()<< "arr = " << arr;

    QString s = arr.toHex();   // 转成16进制
    qDebug()<< "s = " << s <<endl;
    CopySerialDataToBuf(arr);
    cout << "setting sth\n";
    cout << "the string changes"<< endl;
}


QSerialPortInfo Protocoldeal::FindSerial()
{
    QSerialPortInfo com_info;
    foreach (const QSerialPortInfo &info, QSerialPortInfo::availablePorts())
    {
        if( info.serialNumber() == FILE_DEVICE )
        {
            com_info = info;
            break;
        }
    }
    qDebug() << "Name : " << com_info.portName();
    qDebug() << "Description : " << com_info.description();
    qDebug() << "serialNumber: " << com_info.serialNumber();
    return com_info;
}


//将串口数据拷贝到缓冲区
void ProducerFromBottom::CopySerialDataToBuf(QByteArray arr)
{
    static int position = 0;      //相对于数组首地址的偏移
    ConsumerFromBottom CFormBottom;
    int len = arr.length();
    // 当本次从串口获取的数据长度加上当前位置小于最大长度时，继续拷贝，否则从头拷贝
    if (len + position < MAX_LENGTH)
    {
        // 完整写数据的次数超过完整读数据的次数一次时 0~4095计作完整的一次
        if (1 == ProCounts - CFormBottom.GetConCounts())
        {
            // 完整写数据的次数超过完整读数据的次数一次时,
            // 此时写数据的指针位置必须是比读指针的位置小的时候才能写入数据，否则会覆盖掉未读取的数据
            if (totalBuf + position < CFormBottom.GetPointPosition())
            {
                memcpy(totalBuf + position, arr, len); // 从上一次结束的位置的下一个位置进行拷贝
                position = position + len;             // 拷贝结束，更新position的值
            }
        }
        // 完整写数据的次数等于完整读数据的次数时
        else if (0 == ProCounts - CFormBottom.GetConCounts())
        {
            // 写数据的次数等于读数据的次数时
            // 此时写数据的指针位置大于读数据的指针位置时，才可以继续写入数据
            if (totalBuf + position > CFormBottom.GetPointPosition())
            {
                memcpy(totalBuf + position, arr, len); // 从上一次结束的位置的下一个位置进行拷贝
                position = position + len;             // 拷贝结束，更新position的值
            }
        }
        else
        {
            // 超过1次之后不能再往缓冲区写入数据
        }
    }
    else
    {
        position = 0;
        ProCounts ++;  // 0～4095计数一次计算完整的读写次数
        memcpy(totalBuf + position, arr, len);
        position = position + len;
    }
    ProducerFromBottom_pointer += arr.length() - 1;
    qDebug()<<"ProducerFromBottom_pointer = "<< *ProducerFromBottom_pointer;
    qDebug()<<"ProducerFromBottom_pointer = "<< *ProducerFromBottom_pointer;
}

