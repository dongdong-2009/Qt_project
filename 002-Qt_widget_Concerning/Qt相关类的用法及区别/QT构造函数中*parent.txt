http://blog.sina.com.cn/s/blog_6340cd9c0100rabk.html
程序写的多了，你会发现几乎所有的Qt类的构造函数都会有一个parent参数。这个参数通常是QObject* 或者是 QWidget* 类型的(定义新的类是通常首先初始化为0，在类的实现函数中赋值)。很多情况下它都会有一个初始值0，因此，即便你不去给它复制也没有丝毫的问题。于是，稍微偷懒一下，就会不自觉的忽略了这个参数。那么，这个参数 到底是干什么用的呢？

有了此参数，子类才会继承父类在构造函数中初始化了的数据，否则，父类的初始化数据的构造函数不执行，无法继承数据，如果把数据定为私有的，又不便于类的通用继承。
 
其实，这个参数有很多用处。就像它的名字一样，这个参数指定了组件的父组件。对于一个对话框来说，对话框一般是不作为顶层容器出现的，因此在任 务栏上一般是没有对话框的位置的。怎么指定这个对话框不是顶层容器呢？有父组件的组件不就不是顶层容器了吗？因此，只要你指定对话框的parent属性， 任务栏就不会出现它的身影。当然，如果你不指定，这个对话框就成为顶层容器了，任务栏会给它留个位置的——利用这个特性，就可以实现特殊对话框可以在任务 栏出现的效果，比如“关于”对话框的出现。
 
另外比较通用，也是很重要的作用是，parent参数指明了组件的父组件，这样，当父组件delete时，Qt可以保证所有子组件——也就是 parent指针指向这个组件的所有组件——都会被正确的delete掉。这是Qt能够帮助我们管理一部分内存的原因所在。Qt是通过遍历parent属 性来防止了这一部分内存泄漏的。因此，必要情况下还是不要忘记设置这个parent属性。当然，如果你不声明这个属性，当整个程序关闭时，操作系统会回收 内存——因此我们所说的内存泄漏一般是指我们自己写的应用程序的内部，而不会影响到整个操作系统——当然，如果你实现太可恶，操作系统也会受不了自动关掉 你的程序的:-)


http://www.xuebuyuan.com/779933.html
QT学习笔记——如何调用父类的构造函数

C++.QT学习笔记——如何调用父类的构造函数

派生子类会继承基类的所有成员，除了构造函数和析构函数。也就是说子类是无法继承父类的构造函数和析构函数的.因此，子类对于从父类继承过来的成员变量，若不想自己写构造函数初始化时，就只能先初始化父类中的成员变量，然后再继承过来。如以下程序中：

      子类Student1中的构造方法只有对新增成员int age和string addr的初始化操作，对于从父类继承过来的成员num，name，sex无初始化语句，但子类又不能继承父类的构造方法，要么就另外再写一个初始化语句，可这样操作就造成了重复性语句， 此时就得通过Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) {age=a;addr=ad;}先初始化父类成员变量，从而间接初始化子类从父类继承过来的成员变量。

 #include<iostream>

    #include<string>

    using namespace std;

    class Student

    {

    public:

    Student(int n,string nam,char s)

    {

       num=n;

       name=nam;

       sex=s;

       }

       ~Student(){}

       protected:

       int num;

       string name;

       char sex;

       };

       class Student1:public Student

      {

          Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s)

          {

             age=a;

             addr=ad;

           }

          void show()

          {

           }

        private:

        int age;

        string addr;  

    };       

    int main()

    {

      Student1 stud1(10010,"Wang",'f',19,"BeiJing Road,Shanghai");

      ......

      ......

    }

    以上是对基类Student及子类Student1的定义。

    请注意派生子类构造函数首行的写法：

    Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s)

    其一般形式为

       派生类构造函数名（总参数列表）：基类构造函数名（参数列表）

       {

          派生类中新增数据成员初始化语句；

        }

    冒号前面的部分是派生类构造函数的主干，它的总参数表列中包括基类构造函数所需的参数和对派生类新增的数据成员初始化所需的参数。冒号后面的部分是要调用的基类构造函数及其参数。

    基类构造函数后面括号内的参数表列中只有参数但无参数类型，因为在这里不是定义基类构造函数，而是调用基类构造函数，因此这些参数是实参而不是形参。他们可以是常量、全局变量和派生类构造函数总参数表中的参数。     

    从以上可以看到：在main函数中，建立对象stud1时，有5个参数，其中前3个是用来传递基类构造函数的，后2个用来对派生子类所增加的数据成员初始化。

    上例中也可以将派生类构造函数在类外定义，

    Student1::Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s)

    {

      age=a;

      addr=ad;

    }

    注：在类中对派生子类构造函数作声明时不需要:Student(n,nam,s)，只有定义式才用到。

    以上例子中，调用基类构造函数时的实参是从子类构造函数的总参数表中获得的，也可以不从那传递，直接使用常量或全局变量，如：

    Student1(string nam,char s,int a,string ad):Student(10010,nam,s)

    这样父类的n默认初始化为10010，子类直接把n=10010继承过来，因此所以不用写。



